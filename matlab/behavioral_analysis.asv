function [outputArg1,outputArg2] = behavioral_analysis(processed_annotation)
%UNTITLED2 Summary of this function goes here
%   Detailed explanation goes here
T = processed_annotation.T;
chunk = processed_annotation.chunk;
chunk_indices = processed_annotation.chunk_indices;
annotations = processed_annotation.processed_annotations;
for i=1:height(annotations)
    temp_coord = jsondecode(annotations.temporal_coordinates{i});
    if(length(temp_coord)==2)
        %disp(temp_coord);
        s = round(temp_coord(1)/T);
        e = round(temp_coord(2)/T);
        data = struct();
        for k=1:length(chunk)
            chunk_name = chunk{k};
            indices = chunk_indices.(chunk_name);
            for j=1:size(indices,2)
                if(s>indices(1,j) & s<indices(2,j))
                    disp(chunk_name);
                    frame_start = s;
                    frame_end = min(e, indices(2,j));
                elseif(e>indices(1,j) & e<indices(2,j))
                    disp(chunk_name);
                    frame_start = max(s, indices(1,j));
                    frame_end = e;
                else
                    frame_start = 0;
                    frame_end = 0;
                end
                if(frame_start ~= frame_end)
                    disp(frame_start);
                    disp(frame_end);
                    label = annotations.label{i};
                    data.(sprintf('%s_%d', chunk_name, j)) = [
                    for frame=frame_start:frame_end
                        
                    end
                end
            end
        end
    end
end

outputArg1 = 0;
outputArg2 = 0;
end

